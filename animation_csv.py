import numpy as np
import matplotlib
from matplotlib.animation import FuncAnimation
import pandas as pd  # Import pandas for CSV reading

# Use the TkAgg backend for responsiveness
matplotlib.use('TkAgg')
from matplotlib import pyplot as plt

# ----------------------------------------------------------------------
# 1. Configuration (MUST BE UPDATED BY USER)
# ----------------------------------------------------------------------
# NOTE: Replace this path with the actual file generated by process_c3d_data.py
CSV_FILE_PATH = "estimated_output/filled_k_krok_podstawowy_polonez_1_orig_10m_100f_c1.csv"

# This list must match the TARGET_MARKERS used during CSV generation
TARGET_MARKERS = ['LFHD', 'RFHD', 'LBHD', 'RBHD', 'C7', 'T10', 'CLAV', 'STRN', 'RBAK', 'LSHO', 'LUPA', 'LELB', 'LFRM',
                  'LWRA', 'LWRB', 'LFIN', 'RSHO', 'RUPA', 'RELB', 'RFRM', 'RWRA', 'RWRB', 'RFIN', 'LASI', 'RASI',
                  'LPSI', 'RPSI', 'LTHI', 'LKNE', 'LTIB', 'LANK', 'LHEE', 'LTOE', 'RTHI', 'RKNE', 'RTIB', 'RANK',
                  'RHEE', 'RTOE']

# ----------------------------------------------------------------------
# 2. Data Loading and Reshaping
# ----------------------------------------------------------------------
try:
    # Load the CSV file
    df = pd.read_csv(CSV_FILE_PATH)

    # 2a. Filter out the metadata columns (File_ID, Frame_Index)
    marker_cols = [col for col in df.columns if col not in ['File_ID', 'Frame_Index']]

    # Check if we have the expected number of columns (3 * N_markers)
    if len(marker_cols) != len(TARGET_MARKERS) * 3:
        # This handles cases where some markers were missing in the original C3D files,
        # resulting in NaN columns being dropped by pandas during read.

        # Build the expected column list
        expected_cols = [f'{m}_{axis}' for m in TARGET_MARKERS for axis in ['X', 'Y', 'Z']]

        # Ensure the DataFrame contains all expected columns, filling missing ones with NaN
        df = df.reindex(columns=expected_cols, fill_value=np.nan)
        marker_data_flat = df[expected_cols].values

    else:
        # If columns match the expected structure
        marker_data_flat = df[marker_cols].values

    frames_count = marker_data_flat.shape[0]
    num_markers = len(TARGET_MARKERS)

    # 2b. Reshape the flat data into (N_frames, N_markers, 3)
    # The data is currently (N_frames, 3*N_markers)
    positions = marker_data_flat.reshape(frames_count, num_markers, 3)

    print(f"Data loaded from {CSV_FILE_PATH}")
    print(f"Total Frames: {frames_count}, Markers: {num_markers}")

except FileNotFoundError:
    print(f"ERROR: The file '{CSV_FILE_PATH}' was not found. Please verify the path.")
    exit()
except Exception as e:
    print(f"An error occurred during data loading: {e}")
    exit()

# Separate coordinates for easy access
x = positions[:, :, 0]
y = positions[:, :, 1]
z = positions[:, :, 2]

# ----------------------------------------------------------------------
# 3. Visualization Setup
# ----------------------------------------------------------------------

fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')

# Set consistent axes limits based on the min/max across all frames
x_min, x_max = np.nanmin(x), np.nanmax(x)
y_min, y_max = np.nanmin(y), np.nanmax(y)
z_min, z_max = np.nanmin(z), np.nanmax(z)

ax.set_xlim(x_min, x_max)
ax.set_ylim(y_min, y_max)
ax.set_zlim(z_min, z_max)

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')

# Initialize the scatter plot with the first frame
sc = ax.scatter(x[0, :], y[0, :], z[0, :], c='blue', marker='o', s=20)


# ----------------------------------------------------------------------
# 4. Animation Update Function
# ----------------------------------------------------------------------

def update(frame):
    """
    Updates the 3D scatter plot data for the given frame index.
    """
    # Use the setter for the 3D offsets
    sc._offsets3d = (x[frame, :], y[frame, :], z[frame, :])
    return sc,


# ----------------------------------------------------------------------
# 5. Run Animation
# ----------------------------------------------------------------------

# frames=frames_count: Run once for every frame
# interval=30: Delay between frames in ms (approx 33 FPS)
ani = FuncAnimation(fig, update, frames=frames_count, interval=30, blit=False)

# Use tight layout before showing the plot
plt.tight_layout()
plt.show()
